<!DOCTYPE html>
<!--
  OrderBook Density Scanner
  Repo: https://github.com/nothinice/orderbook-density-scanner (replace nothinice)
  Contact: https://t.me/nothinice1
  Build: 2026-01-12
-->
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="description" content="Web tool that scans futures order books and groups symbols by liquidity inside a ¬±X% price range.">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OrderBook Density Scanner</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 32px;
            margin-bottom: 10px;
        }
        
        .header p {
            font-size: 14px;
            opacity: 0.9;
        }
        
        .content {
            padding: 30px;
        }
        
        .controls-section {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
        }
        
        .control-group label {
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
            font-size: 14px;
        }
        
        .control-group input {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.2s;
        }
        
        .control-group input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .control-group select {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.2s;
            background: white;
        }

        .control-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .control-hint {
            font-size: 11px;
            color: #666;
            margin-top: 4px;
            font-style: italic;
        }
        
        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            align-self: flex-end;
            margin-top: auto;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
            margin-left: 5px;
            align-self: auto;
        }
        
        .groups-section {
            margin-bottom: 30px;
        }
        
        .groups-header {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .groups-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(480px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .group-config {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr auto;
            gap: 10px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 6px;
            align-items: flex-end;
            border-left: 4px solid #667eea;
            width: 100%;
            min-width: 0;
        }
        
        .group-config .control-group {
            margin: 0;
            min-width: 0;
        }
        
        .group-config label {
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        .group-config input {
            padding: 8px;
            font-size: 13px;
            width: 100%;
            min-width: 0;
        }
        
        .btn-delete {
            background: #ff6b6b;
            padding: 8px 12px;
            font-size: 12px;
            align-self: flex-end;
            margin: 0;
        }
        
        .btn-delete:hover {
            background: #ff5252;
        }
        
        .results-section {
            margin-top: 30px;
        }
        
        .results-header {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 20px;
            color: #333;
        }
        
        .group-results {
            margin-bottom: 30px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .group-title {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .group-count {
            background: rgba(255,255,255,0.3);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 13px;
        }
        
        .group-content {
            padding: 20px;
            overflow-x: auto;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }
        
        th {
            background: #f5f5f5;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            border-bottom: 2px solid #e0e0e0;
            color: #333;
        }
        
        td {
            padding: 12px;
            border-bottom: 1px solid #f0f0f0;
        }
        
        tr:hover {
            background: #f9f9f9;
        }
        
        .symbol {
            font-weight: 600;
            color: #667eea;
        }
        
        .empty-group {
            padding: 20px;
            text-align: center;
            color: #999;
            font-style: italic;
        }
        
        .loading {
            text-align: center;
            padding: 20px;
            color: #667eea;
        }
        
        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            border-radius: 6px;
            text-align: center;
        }
        
        .stat-card .value {
            font-size: 24px;
            font-weight: 700;
        }
        
        .stat-card .label {
            font-size: 12px;
            opacity: 0.9;
            margin-top: 5px;
        }
        
        .copy-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #22c55e;
            color: white;
            padding: 15px 20px;
            border-radius: 6px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
            z-index: 1000;
            animation: slideIn 0.3s ease-out;
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @media (max-width: 1024px) {
            .groups-grid {
                grid-template-columns: 1fr;
            }
        }
        
        @media (max-width: 768px) {
            .controls-section {
                grid-template-columns: 1fr;
            }
            
            .group-config {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìä –°–∫–∞–Ω–µ—Ä –ø–ª–æ—Ç–Ω–æ—Å—Ç–∏ —Å—Ç–∞–∫–∞–Ω–∞</h1>
            <p>–û—Ü–µ–Ω–∏–≤–∞–π –ø–ª–æ—Ç–Ω–æ—Å—Ç—å —Å—Ç–∞–∫–∞–Ω–∞ –ø–æ –≥—Ä—É–ø–ø–∞–º (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é: Binance Futures)</p>
        </div>
        
        <div class="content">
            <!-- –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ -->
            <div class="controls-section">
                <div class="control-group">
                    <label for="percentage">–ü—Ä–æ—Ü–µ–Ω—Ç –æ—Ç —Ü–µ–Ω—ã (%)</label>
                    <input type="number" id="percentage" value="7" min="1" max="50" step="0.5">
                    <div class="control-hint">–î–∏–∞–ø–∞–∑–æ–Ω —Ü–µ–Ω—ã –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞</div>
                

                <div class="control-group">
                    <label for="exchange">–ë–∏—Ä–∂–∞</label>
                    <select id="exchange" class="select">
                        <option value="binance" selected>Binance Futures</option>
                        <option value="bybit">Bybit Futures</option>
                    </select>
                    <div class="control-hint">–í—ã–±–æ—Ä –∏—Å—Ç–æ—á–Ω–∏–∫–∞ —Å—Ç–∞–∫–∞–Ω–∞ –∏ —Ü–µ–Ω—ã</div>
                </div>
</div>
                
                <div class="control-group">
                    <label for="symbols">–¢–∏–∫–µ—Ä—ã (—á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é)</label>
                    <input type="text" id="symbols" placeholder="BTCUSDT, ETHUSDT, BNBUSDT" value="">
                    <div class="control-hint">–û—Å—Ç–∞–≤—å –ø—É—Å—Ç–æ –¥–ª—è –ø—Ä–∏–º–µ—Ä–∞</div>
                </div>
                
                <div class="control-group">
                    <label for="limit">–£—Ä–æ–≤–Ω–µ–π –≤ —Å—Ç–∞–∫–∞–Ω–µ</label>
                    <input type="number" id="limit" value="1000" min="1" max="1000" step="1">
                    <div class="control-hint">Binance –¥–æ 1000, Bybit –¥–æ 200 (–æ–≥—Ä–∞–Ω–∏—á–∏—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏)</div>
                </div>
                
                <div class="control-group">
                    <label for="maxConcurrent">–ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤</label>
                    <input type="number" id="maxConcurrent" value="5" min="1" max="20" step="1">
                    <div class="control-hint">–ú–µ–Ω—å—à–µ ‚Äî —Å—Ç–∞–±–∏–ª—å–Ω–µ–µ (–º–µ–Ω—å—à–µ —à–∞–Ω—Å 429)</div>
                </div>

                <div class="control-group">
                    <label for="requestDelay">–ó–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É depth-–∑–∞–ø—Ä–æ—Å–∞–º–∏ (–º—Å)</label>
                    <input type="number" id="requestDelay" value="60" min="0" max="2000" step="10">
                    <div class="control-hint">–ü–æ–º–æ–≥–∞–µ—Ç –Ω–µ —É–ø–∏—Ä–∞—Ç—å—Å—è –≤ –ª–∏–º–∏—Ç—ã –±–∏—Ä–∂–∏</div>
                </div>

                
                <button class="btn" onclick="analyzeNow()">üìà –ê–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å</button>
            </div>
            
            <!-- –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –≥—Ä—É–ø–ø -->
            <div class="groups-section">
                <div class="groups-header">
                    <span>‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –≥—Ä—É–ø–ø –ø–ª–æ—Ç–Ω–æ—Å—Ç–∏</span>
                    <button class="btn btn-small" onclick="addGroup()">+ –î–æ–±–∞–≤–∏—Ç—å –≥—Ä—É–ø–ø—É</button>
                </div>
                <div class="groups-grid" id="groupsConfig"></div>
            </div>
            
            <!-- –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ -->
            <div class="stats" id="stats"></div>
            
            <!-- –†–µ–∑—É–ª—å—Ç–∞—Ç—ã -->
            <div class="results-section">
                <div class="results-header">üìã –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –∞–Ω–∞–ª–∏–∑–∞</div>
                <button class="btn btn-small" id="copyBtn" style="display: none;" onclick="copyResults()">üìã –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã</button>
                <div id="results"></div>
            </div>
        </div>
    </div>

    <script>
        let LIQUIDITY_GROUPS = {
    1: { name: "Group 2M+",        min: 2_000_000, max: Infinity },
    2: { name: "Group 1,5M-2M",    min: 1_500_000, max: 2_000_000 },
    3: { name: "Group 1M-1.5M",    min: 1_000_000, max: 1_500_000 },
    4: { name: "Group 800K-1M",    min:   800_000, max: 1_000_000 },
    5: { name: "Group 500K-800K",  min:   500_000, max:   800_000 },
    6: { name: "Group 250K-500K",  min:   250_000, max:   500_000 },
    7: { name: "Group 100K-250K",  min:   100_000, max:   250_000 },
    8: { name: "Group 0-100K",     min:         0, max:   100_000 }
};

        let allData = {};
        let nextGroupId = 9;



// --- Persistence (localStorage) ---
const STORAGE_KEY = 'orderbook_density_scanner_state_v1';
let saveTimer = null;

function getStateFromUI() {
    // Ensure group edits in UI are reflected in LIQUIDITY_GROUPS before saving
    updateGroupLimits();
    const exchange = (document.getElementById('exchange') || {}).value || 'binance';
    const percentage = parseFloat(document.getElementById('percentage').value) || 7;
    const symbols = (document.getElementById('symbols').value || '').trim();
    const limit = parseInt(document.getElementById('limit').value) || 1000;

    const groupsArray = Object.keys(LIQUIDITY_GROUPS)
        .map(id => parseInt(id, 10))
        .sort((a, b) => a - b)
        .map(id => {
            const g = LIQUIDITY_GROUPS[id];
            return {
                id,
                name: String(g.name || `Group ${id}`),
                min: Number(g.min) || 0,
                // JSON –Ω–µ —É–º–µ–µ—Ç Infinity ‚Äî —Å–æ—Ö—Ä–∞–Ω—è–µ–º –∫–∞–∫ null
                max: Number.isFinite(g.max) ? Number(g.max) : null
            };
        });

    return { exchange, percentage, symbols, limit, groupsArray, nextGroupId };
}

function applyStateToUI(state) {
    if (!state || typeof state !== 'object') return;

    if (state.exchange && document.getElementById('exchange')) {
        document.getElementById('exchange').value = state.exchange;
    }
    if (state.percentage != null && document.getElementById('percentage')) {
        document.getElementById('percentage').value = state.percentage;
    }
    if (state.symbols != null && document.getElementById('symbols')) {
        document.getElementById('symbols').value = state.symbols;
    }
    if (state.limit != null && document.getElementById('limit')) {
        document.getElementById('limit').value = state.limit;
    }
}

function saveState(immediate = false) {
    const doSave = () => {
        try {
            const state = getStateFromUI();
            localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
        } catch (e) {
            // –ï—Å–ª–∏ localStorage –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω (—Ä–µ–¥–∫–æ), –ø—Ä–æ—Å—Ç–æ –º–æ–ª—á–∞ –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º
            console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏:', e);
        }
    };

    if (immediate) {
        if (saveTimer) clearTimeout(saveTimer);
        doSave();
        return;
    }

    if (saveTimer) clearTimeout(saveTimer);
    saveTimer = setTimeout(doSave, 250);
}

function loadState() {
    try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return;
        const state = JSON.parse(raw);

        // –í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≥—Ä—É–ø–ø—ã
        if (Array.isArray(state.groupsArray) && state.groupsArray.length) {
            const newGroups = {};
            state.groupsArray.forEach(g => {
                const id = parseInt(g.id, 10);
                if (!Number.isFinite(id)) return;
                newGroups[id] = {
                    name: String(g.name || `Group ${id}`),
                    min: Number(g.min) || 0,
                    max: (g.max === null || g.max === '' || g.max === undefined) ? Infinity : Number(g.max)
                };
            });
            // –ï—Å–ª–∏ –≤–¥—Ä—É–≥ –ø–æ–ª—É—á–∏–ª–æ—Å—å –ø—É—Å—Ç–æ ‚Äî –Ω–µ —Ç—Ä–æ–≥–∞–µ–º
            if (Object.keys(newGroups).length) {
                LIQUIDITY_GROUPS = newGroups;
            }
        }

        // nextGroupId: –ª–∏–±–æ –∏–∑ —Å–æ—Å—Ç–æ—è–Ω–∏—è, –ª–∏–±–æ –≤—ã—á–∏—Å–ª—è–µ–º –±–µ–∑–æ–ø–∞—Å–Ω–æ
        if (Number.isFinite(state.nextGroupId)) {
            nextGroupId = state.nextGroupId;
        } else {
            const maxId = Math.max(...Object.keys(LIQUIDITY_GROUPS).map(n => parseInt(n, 10)).filter(Number.isFinite));
            nextGroupId = (Number.isFinite(maxId) ? maxId + 1 : 1);
        }

        applyStateToUI(state);
    } catch (e) {
        console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏:', e);
    }
}

function bindAutoSave() {
    const ids = ['exchange', 'percentage', 'symbols', 'limit'];
    ids.forEach(id => {
        const el = document.getElementById(id);
        if (!el) return;
        el.addEventListener('input', () => saveState(false));
        el.addEventListener('change', () => saveState(true));
    });

    // –î–µ–ª–µ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–±—ã—Ç–∏–π –Ω–∞ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –≥—Ä—É–ø–ø (–≥—Ä—É–ø–ø—ã –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ)
    const groupsContainer = document.getElementById('groupsConfig');
    if (groupsContainer) {
        groupsContainer.addEventListener('input', () => saveState(false));
        groupsContainer.addEventListener('change', () => saveState(true));
    }
}

        // –ü—Ä–æ–ø—É—â–µ–Ω–Ω—ã–µ —Ç–∏–∫–µ—Ä—ã (—á—Ç–æ–±—ã –±—ã–ª–æ –≤–∏–¥–Ω–æ, –ø–æ—á–µ–º—É –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –ø–∞—Ä—ã –Ω–µ –ø–æ–ø–∞–ª–∏ –≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç)
        let skipped = []; // { symbol, reason }
        let abortInfo = null; // { reason, untilMs }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function createRateLimitState({ minIntervalMs = 0 } = {}) {
            return {
                minIntervalMs,
                nextAllowedAt: 0,
                lastRequestAt: 0,
                queue: Promise.resolve()
            };
        }

        async function rateLimitWait(state) {
            if (!state) return;
            state.queue = state.queue.then(async () => {
                const now = Date.now();
                const waitUntil = Math.max(
                    state.nextAllowedAt || 0,
                    (state.lastRequestAt || 0) + (state.minIntervalMs || 0)
                );
                const waitMs = Math.max(0, waitUntil - now);
                if (waitMs) await sleep(waitMs);
                state.lastRequestAt = Date.now();
            });
            await state.queue;
        }

        async function fetchJsonWithRetry(url, retries = 2, backoffMs = 250, options = {}) {
            let lastErr = null;
            for (let attempt = 0; attempt <= retries; attempt++) {
                try {
                    await rateLimitWait(options.rateLimitState);
                    const resp = await fetch(url);
                    if (!resp.ok) {
                        const txt = await resp.text().catch(() => '');
                        const err = new Error(`HTTP ${resp.status} ${resp.statusText}${txt ? ' - ' + txt.slice(0, 160) : ''}`);
                        
                        err.status = resp.status;
                        const ra = resp.headers ? resp.headers.get("Retry-After") : null;
                        err.retryAfterMs = ra ? (parseFloat(ra) * 1000) : null;
                        const banMatch = txt.match(/banned until (\d+)/i);
                        err.banUntilMs = banMatch ? Number(banMatch[1]) : null;
                        // –ü–æ–≤—Ç–æ—Ä—è–µ–º —Ç–æ–ª—å–∫–æ –Ω–∞ –ª–∏–º–∏—Ç–∞—Ö –∏ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ—à–∏–±–∫–∞—Ö
                        if (resp.status === 429 || resp.status === 418 || resp.status >= 500) throw err;
                        return { ok: false, error: err.message, errorObj: err };
                    }
                    const data = await resp.json();
                    return { ok: true, data };
                } catch (e) {
                    lastErr = e;
                    if (options.rateLimitState) {
                        const now = Date.now();
                        if (e && e.retryAfterMs && isFinite(e.retryAfterMs)) {
                            options.rateLimitState.nextAllowedAt = Math.max(options.rateLimitState.nextAllowedAt || 0, now + e.retryAfterMs);
                        }
                        if (e && e.banUntilMs && isFinite(e.banUntilMs)) {
                            options.rateLimitState.nextAllowedAt = Math.max(options.rateLimitState.nextAllowedAt || 0, e.banUntilMs);
                            if (typeof options.onBan === 'function') options.onBan(e);
                            break;
                        }
                    }
                    if (attempt < retries) {
                        {
                        let delay = backoffMs * Math.pow(2, attempt);
                        // –ù–∞ 429 Binance —á–∞—Å—Ç–æ –ø—Ä–æ—Å–∏—Ç –∑–∞–º–µ–¥–ª–∏—Ç—å—Å—è: –¥–µ–ª–∞–µ–º –±–æ–ª–µ–µ –∞–≥—Ä–µ—Å—Å–∏–≤–Ω—ã–π backoff + jitter
                        const status = e && (e.status || e.httpStatus);
                        if (status === 429) {
                            delay = Math.max(delay, 800 * Math.pow(2, attempt));
                            if (e.retryAfterMs && isFinite(e.retryAfterMs)) delay = Math.max(delay, e.retryAfterMs);
                        }
                        if (status === 418) {
                            delay = Math.max(delay, 1500 * Math.pow(2, attempt));
                        }
                        // Jitter +/- 30%
                        const jitter = delay * (0.15 + Math.random() * 0.15);
                        await sleep(delay + jitter);
                    }
                        continue;
                    }
                }
            }
            return { ok: false, error: lastErr ? String(lastErr.message || lastErr) : 'Unknown error', errorObj: lastErr };
        }

        
        function formatUSDShort(n) {
            const num = Number(n);
            if (!isFinite(num)) return '';
            const abs = Math.abs(num);
            let val, suffix = '';
            if (abs >= 1e9) { val = num / 1e9; suffix = 'B'; }
            else if (abs >= 1e6) { val = num / 1e6; suffix = 'M'; }
            else if (abs >= 1e3) { val = num / 1e3; suffix = 'K'; }
            else { return String(Math.round(num)); }

            const rounded = Math.round(val * 10) / 10; // 1 –∑–Ω–∞–∫
            const s = (Number.isInteger(rounded) ? String(rounded) : String(rounded).replace('.', ','));
            return s + suffix;
        }

        function buildAutoGroupName(min, max) {
            const minNum = Number(min) || 0;
            const maxNum = (max === Infinity || max === null || max === '' || !isFinite(Number(max))) ? Infinity : Number(max);

            if (maxNum === Infinity) {
                return `Group ${formatUSDShort(minNum)}+`;
            }
            if (minNum <= 0) {
                return `Group 0-${formatUSDShort(maxNum)}`;
            }
            return `Group ${formatUSDShort(minNum)}-${formatUSDShort(maxNum)}`;
        }

function initializeGroupsUI() {
            const container = document.getElementById('groupsConfig');
            container.innerHTML = '';
            
            Object.entries(LIQUIDITY_GROUPS).forEach(([id, group]) => {
                const div = document.createElement('div');
                div.className = 'group-config';
                div.innerHTML = `
                    <div class="control-group">
                        <label>–ù–∞–∑–≤–∞–Ω–∏–µ</label>
                        <input type="text" class="group-name" data-group="${id}" value="${group.name}">
                    </div>
                    <div class="control-group">
                        <label>–ú–∏–Ω–∏–º—É–º (USD)</label>
                        <input type="number" class="group-min" data-group="${id}" value="${group.min}" step="10000">
                    </div>
                    <div class="control-group">
                        <label>–ú–∞–∫—Å–∏–º—É–º (USD)</label>
                        <input type="number" class="group-max" data-group="${id}" value="${group.max === Infinity ? '' : group.max}" placeholder="‚àû" step="10000">
                    </div>
                    ${Object.keys(LIQUIDITY_GROUPS).length > 1 ? `<button class="btn btn-delete" onclick="deleteGroup(${id})">‚úï</button>` : ''}
                `;
                // –ê–≤—Ç–æ-–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–∞–∑–≤–∞–Ω–∏—è –≥—Ä—É–ø–ø—ã –ø–æ min/max
                const nameEl = div.querySelector('.group-name');
                const minEl  = div.querySelector('.group-min');
                const maxEl  = div.querySelector('.group-max');

                const syncName = () => {
                    const minVal = parseFloat(minEl.value) || 0;
                    const rawMax = (maxEl.value || '').trim();
                    const maxVal = rawMax === '' ? Infinity : (parseFloat(rawMax) || Infinity);
                    const autoName = buildAutoGroupName(minVal, maxVal);
                    nameEl.value = autoName;
                    LIQUIDITY_GROUPS[id].name = autoName;
                    LIQUIDITY_GROUPS[id].min = minVal;
                    LIQUIDITY_GROUPS[id].max = (rawMax === '' ? Infinity : maxVal);
                    saveState(false);
                };

                // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–º–µ–Ω–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç–µ–∫—É—â–∏—Ö min/max
                nameEl.value = buildAutoGroupName(group.min, group.max);
                LIQUIDITY_GROUPS[id].name = nameEl.value;

                minEl.addEventListener('input', syncName);
                maxEl.addEventListener('input', syncName);
                
                container.appendChild(div);
            });
        }

        function addGroup() {
            const newId = nextGroupId++;
            LIQUIDITY_GROUPS[newId] = { name: `Group ${newId}`, min: 0, max: Infinity };
            initializeGroupsUI();
            saveState(true);
        }

        function deleteGroup(id) {
            if (Object.keys(LIQUIDITY_GROUPS).length > 1) {
                delete LIQUIDITY_GROUPS[id];
                initializeGroupsUI();
                saveState(true);
            } else {
                alert('–î–æ–ª–∂–Ω–∞ –±—ã—Ç—å —Ö–æ—Ç—è –±—ã –æ–¥–Ω–∞ –≥—Ä—É–ø–ø–∞!');
            }
        }

        function updateGroupLimits() {
            document.querySelectorAll('.group-name, .group-min, .group-max').forEach(input => {
                const groupId = parseInt(input.dataset.group);
                if (input.classList.contains('group-name')) {
                    LIQUIDITY_GROUPS[groupId].name = input.value;
                } else if (input.classList.contains('group-min')) {
                    LIQUIDITY_GROUPS[groupId].min = parseFloat(input.value) || 0;
                } else {
                    const val = input.value.trim();
                    LIQUIDITY_GROUPS[groupId].max = val === '' ? Infinity : parseFloat(val);
                }
            });
        }

        async function analyzeNow() {
            const percentage = parseFloat(document.getElementById('percentage').value) || 7;
            const maxConcurrent = parseInt(document.getElementById('maxConcurrent')?.value) || 5;
            const requestDelay = parseInt(document.getElementById('requestDelay')?.value) || 0;
            const symbolsInput = document.getElementById('symbols').value.trim();
            const limit = parseInt(document.getElementById('limit').value) || 100;
            
            updateGroupLimits();
            
            saveState(true);

            const defaultSymbols = ['BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'XRPUSDT', 'ADAUSDT'];
            const symbols = symbolsInput ? symbolsInput.split(/[\s,;]+/).map(s => s.trim()).filter(Boolean).map(s => s.toUpperCase()) : defaultSymbols;
            
            const exchange = getCurrentExchange();
            const effectiveLimit = Math.min(limit, exchange.maxDepth);
            await analyzeSymbols(symbols, percentage, effectiveLimit, exchange, { maxConcurrent, requestDelay });
        }

        async function analyzeSymbols(symbols, percentage, limit, exchange, opts = {}) {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = `<div class="loading"><div class="spinner"></div>–ê–Ω–∞–ª–∏–∑–∏—Ä—É—é... <div style="font-size: 12px; opacity: 0.8; margin-top: 6px;">–ë–∏—Ä–∂–∞: <strong>${exchange?.name || 'Binance Futures'}</strong>, –≥–ª—É–±–∏–Ω–∞: <strong>${limit}</strong></div><div style=\"font-size: 12px; opacity: 0.8; margin-top: 6px;\">–ü—Ä–æ–≥—Ä–µ—Å—Å: <strong><span id=\"progress\">0</span></strong></div></div>`;
            
            allData = {};
            skipped = [];
            abortInfo = null;
            Object.keys(LIQUIDITY_GROUPS).forEach(id => allData[id] = []);

            const maxConcurrent = Math.max(1, Math.min(50, parseInt(opts.maxConcurrent) || 5));
            const requestDelay = Math.max(0, parseInt(opts.requestDelay) || 0);

            // Promise pool —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ–º –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ—Å—Ç–∏ + –Ω–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –ø–µ—Ä–µ–¥ –∫–∞–∂–¥—ã–º depth-–∑–∞–ø—Ä–æ—Å–æ–º
            let idx = 0;
            const total = symbols.length;
            const progressEl = document.getElementById('progress');
            const updateProgressUI = () => {
                if (!progressEl) return;
                const done = Math.min(total, idx);
                progressEl.textContent = `${done}/${total}`;
            };

            const worker = async () => {
                while (true) {
                    if (abortInfo) return;
                    const myIndex = idx++;
                    if (myIndex >= total) return;
                    const symbol = symbols[myIndex];

                    try {
                        if (requestDelay) await sleep(requestDelay);

                        const orderBook = await exchange.getOrderBook(symbol, limit);
                        if (!orderBook || !orderBook.bids || !orderBook.asks || !orderBook.bids.length || !orderBook.asks.length) {
                            skipped.push({ symbol, reason: '–Ω–µ—Ç —Å—Ç–∞–∫–∞–Ω–∞ (–ø—É—Å—Ç–æ–π –æ—Ç–≤–µ—Ç)' });
                            updateProgressUI();
                            continue;
                        }

                        // –¶–µ–Ω–∞ –¥–ª—è –∫–æ—Ä–∏–¥–æ—Ä–∞ –±–µ—Ä—ë–º –∏–∑ —ç—Ç–æ–≥–æ –∂–µ —Å–Ω–∞–ø—à–æ—Ç–∞ —Å—Ç–∞–∫–∞–Ω–∞ (mid = (bestBid+bestAsk)/2)
                        let price = getMidPriceFromBook(orderBook);

                        // fallback (–Ω–∞ —Å–ª—É—á–∞–π —Ä–µ–¥–∫–∏—Ö –æ—à–∏–±–æ–∫): lastPrice
                        if (!price || !isFinite(price)) {
                            price = await exchange.getPrice(symbol);
                        }
                        if (!price || !isFinite(price)) {
                            skipped.push({ symbol, reason: '–Ω–µ—Ç —Ü–µ–Ω—ã (mid/lastPrice –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã)' });
                            updateProgressUI();
                            continue;
                        }

                        // Coverage –≤ —Ä–∞–º–∫–∞—Ö –∑–∞–¥–∞–Ω–Ω–æ–≥–æ –ø—Ä–æ—Ü–µ–Ω—Ç–∞ (–Ω–µ –ø—Ä–µ–≤—ã—à–∞–µ—Ç percentage)
                        const cov = getCoveragePct(orderBook, price, percentage);

                        const { bidLiquidity, askLiquidity } = calculateLiquidity(orderBook, price, percentage);
                        const totalLiquidity = Math.min(bidLiquidity, askLiquidity);
                        const group = classifyLiquidity(totalLiquidity);

                        allData[group].push({
                            symbol,
                            price: parseFloat(price.toFixed(4)),
                            bidLiquidity: parseFloat(bidLiquidity.toFixed(2)),
                            askLiquidity: parseFloat(askLiquidity.toFixed(2)),
                            minLiquidity: parseFloat(totalLiquidity.toFixed(2)),
                            coverageDownPct: parseFloat(cov.downPct.toFixed(2)),
                            coverageUpPct: parseFloat(cov.upPct.toFixed(2)),
                            coverageOk: (cov.downPct >= percentage && cov.upPct >= percentage)
                        });
                    } catch (e) {
                        if (e && (e.status === 418 || e.banUntilMs)) {
                            const untilMs = e.banUntilMs && isFinite(e.banUntilMs) ? e.banUntilMs : null;
                            const untilText = untilMs ? new Date(untilMs).toLocaleString('ru-RU') : '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ';
                            abortInfo = {
                                reason: `üö´ Binance –≤—Ä–µ–º–µ–Ω–Ω–æ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–ª –∑–∞–ø—Ä–æ—Å—ã (HTTP 418). –ë–∞–Ω –¥–æ: ${untilText}. –†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è —Å–Ω–∏–∑–∏—Ç—å –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ—Å—Ç—å –¥–æ 1‚Äì2, —É–≤–µ–ª–∏—á–∏—Ç—å –∑–∞–¥–µ—Ä–∂–∫—É –∏/–∏–ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å WebSocket.`,
                                untilMs
                            };
                            skipped.push({ symbol, reason: abortInfo.reason });
                            updateProgressUI();
                            return;
                        }
                        const msg = String(e?.message || e);
                        skipped.push({ symbol, reason: msg });
                    } finally {
                        updateProgressUI();
                    }
                }
            };

            // –ó–∞–ø—É—Å–∫–∞–µ–º –ø—É–ª –≤–æ—Ä–∫–µ—Ä–æ–≤
            const workers = Array.from({ length: Math.min(maxConcurrent, symbols.length) }, () => worker());
            await Promise.all(workers);

            displayResults(percentage);


        }

        const binanceRateLimitState = createRateLimitState({ minIntervalMs: 150 });

        const EXCHANGES = {
    binance: {
        key: 'binance',
        name: 'Binance Futures',
        maxDepth: 1000,
        _tradingSymbols: null,
        async _ensureExchangeInfo() {
            if (this._tradingSymbols) return this._tradingSymbols;
            const r = await fetchJsonWithRetry(`https://fapi.binance.com/fapi/v1/exchangeInfo`, 2, 250, { rateLimitState: binanceRateLimitState });
            if (!r.ok) {
                // If exchangeInfo fails, continue without whitelist
                this._tradingSymbols = null;
                return null;
            }
            const set = new Set();
            const list = r.data?.symbols || [];
            for (const s of list) {
                if (s && s.symbol && s.status === 'TRADING') set.add(String(s.symbol));
            }
            this._tradingSymbols = set;
            return set;
        },
        async getPrice(symbol) {
            const wl = await this._ensureExchangeInfo();
            if (wl && !wl.has(symbol)) throw new Error(`Symbol not TRADING on Binance Futures: ${symbol}`);
            const r = await fetchJsonWithRetry(`https://fapi.binance.com/fapi/v1/ticker/24hr?symbol=${symbol}`, 2, 250, { rateLimitState: binanceRateLimitState });
            if (!r.ok) throw (r.errorObj || new Error(r.error || 'ticker error'));
            const data = r.data;
            const p = parseFloat(data?.lastPrice);
            if (!isFinite(p)) throw new Error('Invalid lastPrice');
            return p;
        },
        async getOrderBook(symbol, limit) {
            const wl = await this._ensureExchangeInfo();
            if (wl && !wl.has(symbol)) throw new Error(`Symbol not TRADING on Binance Futures: ${symbol}`);
            const r = await fetchJsonWithRetry(
                `https://fapi.binance.com/fapi/v1/depth?symbol=${symbol}&limit=${limit}`,
                2,
                250,
                { rateLimitState: binanceRateLimitState }
            );
            if (!r.ok) throw (r.errorObj || new Error(r.error || 'depth error'));
            const data = r.data;
            const bids = data?.bids || [];
            const asks = data?.asks || [];
            if (!bids.length || !asks.length) throw new Error('Empty order book');
            return { bids, asks };
        }
},
    bybit: {
        key: 'bybit',
        name: 'Bybit Futures',
        maxDepth: 200,
        async getPrice(symbol) {
            const r = await fetchJsonWithRetry(`https://api.bybit.com/v5/market/tickers?category=linear&symbol=${symbol}`);
            if (!r.ok) throw (r.errorObj || new Error(r.error || 'bybit tickers error'));
            const data = r.data;
            if (data?.retCode && data.retCode !== 0) throw new Error(`Bybit retCode ${data.retCode}: ${data.retMsg || 'error'}`);
            const item = data?.result?.list?.[0];
            const p = item ? parseFloat(item.lastPrice) : NaN;
            if (!isFinite(p)) throw new Error('Invalid lastPrice');
            return p;
        },
        async getOrderBook(symbol, limit) {
            const r = await fetchJsonWithRetry(`https://api.bybit.com/v5/market/orderbook?category=linear&symbol=${symbol}&limit=${limit}`);
            if (!r.ok) throw (r.errorObj || new Error(r.error || 'bybit orderbook error'));
            const data = r.data;
            if (data?.retCode && data.retCode !== 0) throw new Error(`Bybit retCode ${data.retCode}: ${data.retMsg || 'error'}`);
            const res = data?.result;
            const bids = res?.b || [];
            const asks = res?.a || [];
            if (!bids.length || !asks.length) throw new Error('empty orderbook');
            return { bids, asks };
        }
    }
};

function getCurrentExchange() {
    const key = (document.getElementById('exchange')?.value || 'binance');
    return EXCHANGES[key] || EXCHANGES.binance;
}


        function calculateLiquidity(orderBook, currentPrice, percentage) {
            const priceLevelLow = currentPrice * (1 - percentage / 100);
            const priceLevelHigh = currentPrice * (1 + percentage / 100);
            
            let bidLiquidity = 0;
            let askLiquidity = 0;
            
            (orderBook.bids || []).forEach(([priceStr, qtyStr]) => {
                const price = parseFloat(priceStr);
                const qty = parseFloat(qtyStr);
                if (price >= priceLevelLow && price <= currentPrice) {
                    bidLiquidity += price * qty;
                }
            });
            
            (orderBook.asks || []).forEach(([priceStr, qtyStr]) => {
                const price = parseFloat(priceStr);
                const qty = parseFloat(qtyStr);
                if (price >= currentPrice && price <= priceLevelHigh) {
                    askLiquidity += price * qty;
                }
            });
            
            return { bidLiquidity, askLiquidity };
        }

        function getBestBidAsk(orderBook) {
            const bids = orderBook?.bids || [];
            const asks = orderBook?.asks || [];

            let bestBid = null; // max bid price
            for (const lvl of bids) {
                const p = parseFloat(lvl?.[0]);
                if (isFinite(p) && p > 0) {
                    if (bestBid === null || p > bestBid) bestBid = p;
                }
            }

            let bestAsk = null; // min ask price
            for (const lvl of asks) {
                const p = parseFloat(lvl?.[0]);
                if (isFinite(p) && p > 0) {
                    if (bestAsk === null || p < bestAsk) bestAsk = p;
                }
            }

            return { bestBid, bestAsk };
        }

        function getMidPriceFromBook(orderBook) {
            const { bestBid, bestAsk } = getBestBidAsk(orderBook);
            if (!isFinite(bestBid) || !isFinite(bestAsk) || bestBid <= 0 || bestAsk <= 0) return null;
            return (bestBid + bestAsk) / 2;
        }

        function getCoveragePct(orderBook, midPrice, targetPct) {
            // Returns how much of the *requested* +/- targetPct band is actually covered
            // by the available depth snapshot (never exceeds targetPct).
            const bids = orderBook?.bids || [];
            const asks = orderBook?.asks || [];
            if (!bids.length || !asks.length || !isFinite(midPrice) || midPrice <= 0 || !isFinite(targetPct) || targetPct <= 0) {
                return { downPct: 0, upPct: 0 };
            }

            const lower = midPrice * (1 - targetPct / 100);
            const upper = midPrice * (1 + targetPct / 100);

            // Find the furthest prices we actually have on each side.
            let minBid = Infinity;
            for (const [p] of bids) {
                const px = parseFloat(p);
                if (isFinite(px) && px > 0 && px < minBid) minBid = px;
            }
            let maxAsk = -Infinity;
            for (const [p] of asks) {
                const px = parseFloat(p);
                if (isFinite(px) && px > 0 && px > maxAsk) maxAsk = px;
            }

            // If the book is malformed, bail out safely.
            if (!isFinite(minBid) || !isFinite(maxAsk)) {
                return { downPct: 0, upPct: 0 };
            }

            // Compute raw coverage based on available depths, then clamp to the requested band.
            const rawDown = (midPrice - minBid) / midPrice * 100;
            const rawUp   = (maxAsk - midPrice) / midPrice * 100;

            // If we have levels beyond the requested bounds, consider it fully covered.
            const downPct = (minBid <= lower) ? targetPct : Math.max(0, Math.min(targetPct, rawDown));
            const upPct   = (maxAsk >= upper) ? targetPct : Math.max(0, Math.min(targetPct, rawUp));

            return { downPct, upPct };
        }

        

        function classifyLiquidity(liquidity) {
            for (let groupId of Object.keys(LIQUIDITY_GROUPS).map(Number).sort((a, b) => b - a)) {
                const group = LIQUIDITY_GROUPS[groupId];
                if (liquidity >= group.min && liquidity < group.max) {
                    return groupId;
                }
            }
            return Object.keys(LIQUIDITY_GROUPS)[0];
        }

        function displayResults(percentage) {
            const resultsDiv = document.getElementById('results');
            let html = '';

            if (abortInfo && abortInfo.reason) {
                html += `
                    <div class="group-results" style="border-left-color:#ff6b6b;">
                        <div class="group-title">
                            <span>üö´ –ü—Ä–µ—Ä–≤–∞–Ω–æ –∏–∑-–∑–∞ –ª–∏–º–∏—Ç–æ–≤</span>
                            <span class="group-count">—Ç—Ä–µ–±—É–µ—Ç—Å—è –ø–∞—É–∑–∞</span>
                        </div>
                        <div class="group-content" style="color:#b91c1c; font-weight:600;">
                            ${abortInfo.reason}
                        </div>
                    </div>
                `;
            }
            
            let totalSymbols = 0;
            Object.values(allData).forEach(group => {
                totalSymbols += group.length;
            });
            
            const statsDiv = document.getElementById('stats');
            statsDiv.innerHTML = '';
            Object.entries(LIQUIDITY_GROUPS).forEach(([id, group]) => {
                const count = allData[id] ? allData[id].length : 0;
                statsDiv.innerHTML += `
                    <div class="stat-card">
                        <div class="value">${count}</div>
                        <div class="label">${group.name}</div>
                    </div>
                `;
            });
            
            document.getElementById('copyBtn').style.display = 'inline-block';
            
            Object.entries(LIQUIDITY_GROUPS).forEach(([id, group]) => {
                const items = (allData[id] || []).sort((a, b) => b.minLiquidity - a.minLiquidity);
                
                html += `
                    <div class="group-results">
                        <div class="group-title">
                            <span>${group.name}</span>
                            <span class="group-count">${items.length} —Ç–∏–∫–µ—Ä–æ–≤</span>
                        </div>
                        <div class="group-content">
                            ${items.length === 0 ? '<div class="empty-group">–ù–µ—Ç —Ç–∏–∫–µ—Ä–æ–≤ –≤ —ç—Ç–æ–π –≥—Ä—É–ø–ø–µ</div>' : `
                                <table>
                                    <thead>
                                        <tr>
                                            <th>–°–∏–º–≤–æ–ª</th>
                                            <th>–¶–µ–Ω–∞</th>
                                            <th>Bid (LONG)</th>
                                            <th>Ask (SHORT)</th>
                                            <th>–ü–æ–∫—Ä—ã—Ç–∏–µ</th>
                                            <th>–ú–∏–Ω–∏–º—É–º (USD)</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${items.map(item => `
                                            <tr>
                                                <td class="symbol">${item.symbol}</td>
                                                <td>${item.price.toFixed(4)}</td>
                                                <td>${item.bidLiquidity.toLocaleString('ru-RU', {maximumFractionDigits: 0})}</td>
                                                <td>${item.askLiquidity.toLocaleString('ru-RU', {maximumFractionDigits: 0})}</td>
                                                <td title="–ù–∞—Å–∫–æ–ª—å–∫–æ –≥–ª—É–±–∏–Ω–∞ —Å—Ç–∞–∫–∞–Ω–∞ –ø–æ–∫—Ä—ã–ª–∞ –¥–∏–∞–ø–∞–∑–æ–Ω –≤–æ–∫—Ä—É–≥ mid-price">
                                                    ${(item.coverageDownPct ?? 0).toFixed(2)}% / ${(item.coverageUpPct ?? 0).toFixed(2)}%${item.coverageOk ? '' : ' ‚ö†Ô∏è'}
                                                </td>
                                                <td><strong>${item.minLiquidity.toLocaleString('ru-RU', {maximumFractionDigits: 0})}</strong></td>
                                            </tr>
                                        `).join('')}
                                    </tbody>
                                </table>
                            `}
                        </div>
                    </div>
                `;
            });
            
            // –ë–ª–æ–∫ –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã—Ö —Ç–∏–∫–µ—Ä–æ–≤
            if (skipped && skipped.length) {
                html += `
                    <div class="group-results">
                        <div class="group-title">
                            <span>‚ö†Ô∏è –ü—Ä–æ–ø—É—â–µ–Ω–Ω—ã–µ —Ç–∏–∫–µ—Ä—ã</span>
                            <span class="group-count">${skipped.length}</span>
                        </div>
                        <div class="group-content">
                            <table>
                                <thead>
                                    <tr>
                                        <th>–°–∏–º–≤–æ–ª</th>
                                        <th>–ü—Ä–∏—á–∏–Ω–∞</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${skipped.map(x => `
                                        <tr>
                                            <td class="symbol">${x.symbol}</td>
                                            <td>${(x.reason || '').toString().slice(0, 220)}</td>
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                            <div style="margin-top:10px; font-size:12px; color:#666;">
                                –ß–∞—Å—Ç—ã–µ –ø—Ä–∏—á–∏–Ω—ã: —Ç–∏–∫–µ—Ä –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –Ω–∞ –≤—ã–±—Ä–∞–Ω–Ω–æ–π –±–∏—Ä–∂–µ (USDT linear), –≤—Ä–µ–º–µ–Ω–Ω—ã–π –ª–∏–º–∏—Ç –∑–∞–ø—Ä–æ—Å–æ–≤ (429) –∏–ª–∏ —Å–µ—Ç—å.
                            </div>
                        </div>
                    </div>
                `;
            }

            resultsDiv.innerHTML = html;
        }

        function copyResults() {
            let text = '';
            
            Object.entries(LIQUIDITY_GROUPS).forEach(([id, group]) => {
                const items = (allData[id] || []).sort((a, b) => b.minLiquidity - a.minLiquidity);
                const percentage = parseFloat(document.getElementById('percentage').value) || 7;
                
                text += `${id} ${group.name} ${percentage}%\n`;
                
                if (items.length === 0) {
                    text += '\n';
                } else {
                    const symbols = items.map(item => item.symbol.replace('USDT', '').toLowerCase() + 'usdt').join(', ');
                    text += symbols + '\n\n';
                }
            });
            
            navigator.clipboard.writeText(text).then(() => {
                const notification = document.createElement('div');
                notification.className = 'copy-notification';
                notification.textContent = '‚úÖ –†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω—ã –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞!';
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    notification.remove();
                }, 3000);
            }).catch(() => {
                alert('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å. –ò—Å–ø–æ–ª—å–∑—É–π Ctrl+C –Ω–∞ —Ç–µ–∫—Å—Ç–µ.');
            });
        }

        window.addEventListener('load', () => {
            loadState();
            initializeGroupsUI();
            bindAutoSave();
            // –°–æ—Ö—Ä–∞–Ω–∏–º —Å—Ä–∞–∑—É –ø–æ—Å–ª–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ (–Ω–∞ —Å–ª—É—á–∞–π –ø–µ—Ä–≤–æ–≥–æ –∑–∞–ø—É—Å–∫–∞)
            saveState(true);
        });
</script>

    <div class="footer" style="margin-top:16px; font-size:12px; opacity:0.9; text-align:center;">
        <span>OrderBook Density Scanner ‚Ä¢ </span>
        <a href="https://github.com/nothinice/orderbook-density-scanner" target="_blank" rel="noopener">GitHub</a>
        <span> ‚Ä¢ </span>
        <a href="https://t.me/nothinice1" target="_blank" rel="noopener">Telegram</a>
        <span> ‚Ä¢ Build 2026-01-12</span>
    </div>

</body>
</html>
